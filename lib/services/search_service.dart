import 'package:pangolin/words/CSW21/CSW21_10.dart';
import 'package:pangolin/words/CSW21/CSW21_11.dart';
import 'package:pangolin/words/CSW21/CSW21_12.dart';
import 'package:pangolin/words/CSW21/CSW21_13.dart';
import 'package:pangolin/words/CSW21/CSW21_14.dart';
import 'package:pangolin/words/CSW21/CSW21_15.dart';
import 'package:pangolin/words/CSW21/CSW21_2.dart';
import 'package:pangolin/words/CSW21/CSW21_3.dart';
import 'package:pangolin/words/CSW21/CSW21_4.dart';
import 'package:pangolin/words/CSW21/CSW21_5.dart';
import 'package:pangolin/words/CSW21/CSW21_6.dart';
import 'package:pangolin/words/CSW21/CSW21_7.dart';
import 'package:pangolin/words/CSW21/CSW21_8.dart';
import 'package:pangolin/words/CSW21/CSW21_9.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_10_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_11_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_12_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_13_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_14_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_15_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_2_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_3_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_4_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_5_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_6_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_7_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_8_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_ANAGRAMS/CSW21_9_ANAGRAMS.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_10_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_11_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_12_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_13_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_14_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_15_SORTED.dart';
import 'dart:async';

import 'package:pangolin/words/CSW21_SORTED/CSW21_2_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_3_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_4_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_5_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_6_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_7_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_8_SORTED.dart';
import 'package:pangolin/words/CSW21_SORTED/CSW21_9_SORTED.dart';

import '../words/NWL20/NWL20_10.dart';
import '../words/NWL20/NWL20_11.dart';
import '../words/NWL20/NWL20_12.dart';
import '../words/NWL20/NWL20_13.dart';
import '../words/NWL20/NWL20_14.dart';
import '../words/NWL20/NWL20_15.dart';
import '../words/NWL20/NWL20_2.dart';
import '../words/NWL20/NWL20_3.dart';
import '../words/NWL20/NWL20_4.dart';
import '../words/NWL20/NWL20_5.dart';
import '../words/NWL20/NWL20_6.dart';
import '../words/NWL20/NWL20_7.dart';
import '../words/NWL20/NWL20_8.dart';
import '../words/NWL20/NWL20_9.dart';
import '../words/NWL20_ANAGRAMS/NWL20_10_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_11_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_12_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_13_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_14_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_15_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_2_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_3_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_4_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_5_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_6_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_7_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_8_ANAGRAMS.dart';
import '../words/NWL20_ANAGRAMS/NWL20_9_ANAGRAMS.dart';
import '../words/NWL20_SORTED/NWL20_2_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_3_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_4_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_5_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_6_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_7_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_8_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_9_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_10_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_11_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_12_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_13_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_14_SORTED.dart';
import '../words/NWL20_SORTED/NWL20_15_SORTED.dart';

List<String>? result = [];

// Define the alphabet as a string
String alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
Map<String, Map<String, List<String>>> CSW_lengthToAnagramWordsArrayMap = {
  "2": CSW21_2_ANAGRAMS,
  "3": CSW21_3_ANAGRAMS,
  "4": CSW21_4_ANAGRAMS,
  "5": CSW21_5_ANAGRAMS,
  "6": CSW21_6_ANAGRAMS,
  "7": CSW21_7_ANAGRAMS,
  "8": CSW21_8_ANAGRAMS,
  "9": CSW21_9_ANAGRAMS,
  "10": CSW21_10_ANAGRAMS,
  "11": CSW21_11_ANAGRAMS,
  "12": CSW21_12_ANAGRAMS,
  "13": CSW21_13_ANAGRAMS,
  "14": CSW21_14_ANAGRAMS,
  "15": CSW21_15_ANAGRAMS,
};

Map<String, List<String>> CSW_lengthToSortedWordsArray = {
  "2": CSW21_2_SORTED,
  "3": CSW21_3_SORTED,
  "4": CSW21_4_SORTED,
  "5": CSW21_5_SORTED,
  "6": CSW21_6_SORTED,
  "7": CSW21_7_SORTED,
  "8": CSW21_8_SORTED,
  "9": CSW21_9_SORTED,
  "10": CSW21_10_SORTED,
  "11": CSW21_11_SORTED,
  "12": CSW21_12_SORTED,
  "13": CSW21_13_SORTED,
  "14": CSW21_14_SORTED,
  "15": CSW21_15_SORTED,
};

Map<String, List<String>> CSW_lengthToProbabilityArray = {
  "2": CSW21_2_ARRAY,
  "3": CSW21_3_ARRAY,
  "4": CSW21_4_ARRAY,
  "5": CSW21_5_ARRAY,
  "6": CSW21_6_ARRAY,
  "7": CSW21_7_ARRAY,
  "8": CSW21_8_ARRAY,
  "9": CSW21_9_ARRAY,
  "10": CSW21_10_ARRAY,
  "11": CSW21_11_ARRAY,
  "12": CSW21_12_ARRAY,
  "13": CSW21_13_ARRAY,
  "14": CSW21_14_ARRAY,
  "15": CSW21_15_ARRAY,
};

Map<String, Map<String, List<String>>> NWL20_lengthToAnagramWordsArrayMap = {
  "2": NWL20_2_ANAGRAMS,
  "3": NWL20_3_ANAGRAMS,
  "4": NWL20_4_ANAGRAMS,
  "5": NWL20_5_ANAGRAMS,
  "6": NWL20_6_ANAGRAMS,
  "7": NWL20_7_ANAGRAMS,
  "8": NWL20_8_ANAGRAMS,
  "9": NWL20_9_ANAGRAMS,
  "10": NWL20_10_ANAGRAMS,
  "11": NWL20_11_ANAGRAMS,
  "12": NWL20_12_ANAGRAMS,
  "13": NWL20_13_ANAGRAMS,
  "14": NWL20_14_ANAGRAMS,
  "15": NWL20_15_ANAGRAMS,
};

Map<String, List<String>> NWL20_lengthToSortedWordsArray = {
  "2": NWL20_2_SORTED,
  "3": NWL20_3_SORTED,
  "4": NWL20_4_SORTED,
  "5": NWL20_5_SORTED,
  "6": NWL20_6_SORTED,
  "7": NWL20_7_SORTED,
  "8": NWL20_8_SORTED,
  "9": NWL20_9_SORTED,
  "10": NWL20_10_SORTED,
  "11": NWL20_11_SORTED,
  "12": NWL20_12_SORTED,
  "13": NWL20_13_SORTED,
  "14": NWL20_14_SORTED,
  "15": NWL20_15_SORTED,
};

Map<String, List<String>> NWL20_lengthToProbabilityArray = {
  "2": NWL20_2_ARRAY,
  "3": NWL20_3_ARRAY,
  "4": NWL20_4_ARRAY,
  "5": NWL20_5_ARRAY,
  "6": NWL20_6_ARRAY,
  "7": NWL20_7_ARRAY,
  "8": NWL20_8_ARRAY,
  "9": NWL20_9_ARRAY,
  "10": NWL20_10_ARRAY,
  "11": NWL20_11_ARRAY,
  "12": NWL20_12_ARRAY,
  "13": NWL20_13_ARRAY,
  "14": NWL20_14_ARRAY,
  "15": NWL20_15_ARRAY,
};

Future<List<String>> searchForAnagrams(String input, String lexicon) async {
  // sanitize input
  var sanitizedInput = input.trim().toUpperCase();
  sanitizedInput = sanitizedInput.replaceAll(".", "?");
  var length = sanitizedInput.length;

  // get correct list from lexicon
  late Map<String, List<String>>? correctList;
  switch (lexicon) {
    case "CSW21":
      correctList = CSW_lengthToAnagramWordsArrayMap[length.toString()];
    case "NWL20":
      correctList = NWL20_lengthToAnagramWordsArrayMap[length.toString()];
  }
  return await _searchForAnagrams(sanitizedInput, correctList);
}

Future<List<String>> searchForPatterns(String input, String lexicon) async {
  // sanitize input
  var sanitizedInput = input.trim().toUpperCase();
  sanitizedInput = sanitizedInput.replaceAll(".", "?");
  // get correct list from lexicon
  late List<String>? correctList;
  int length = sanitizedInput.length;
  switch (lexicon) {
    case "CSW21":
      correctList = CSW_lengthToSortedWordsArray[length.toString()];
    case "NWL20":
      correctList = NWL20_lengthToSortedWordsArray[length.toString()];
  }
  return await _searchForPatterns2(sanitizedInput, correctList ?? []);
}

Future<List<String>> searchForProbability(
    int length, int min, int max, String lexicon) async {
  // get correct list from lexicon
  late List<String>? correctList;
  switch (lexicon) {
    case "CSW21":
      correctList = CSW_lengthToProbabilityArray[length.toString()];
    case "NWL20":
      correctList = NWL20_lengthToProbabilityArray[length.toString()];
  }
  return await _searchForProbability(length, min, max, correctList);
}

Future<List<String>> searchForIncludes(
    int length, List<String> includesList, String lexicon) async {
  // sanitize input
  final uppercaseIncludesList =
      includesList.map((char) => char.toUpperCase()).toList();

  // get correct list from lexicon
  late List<String>? correctList;
  switch (lexicon) {
    case "CSW21":
      correctList = CSW_lengthToSortedWordsArray[length.toString()];
    case "NWL20":
      correctList = NWL20_lengthToSortedWordsArray[length.toString()];
  }
  return await _searchForIncludes(length, uppercaseIncludesList, correctList);
}

Future<List<String>> _searchForIncludes(
    int length, List<String> includesList, List<String>? correctList) async {
  List<String>? correctList = CSW_lengthToSortedWordsArray[length.toString()];

  List<String> returnList = correctList!
      .where((word) => includesList.every((char) => word.contains(char)))
      .toList();

  return returnList;
}

Future<List<String>> _searchForProbability(
    int length, int min, int max, List<String>? correctList) async {
  //max is greater than length of correctList
  if (max > correctList!.length) {
    max = correctList.length;
  }
  int protectedMin = min - 1 < 0 ? 0 : min - 1;
  List<String> returnList = correctList.sublist(protectedMin, max);

  return returnList;
}

// Future<List<String>> _searchForPatterns(
//     String input, List<String>? correctList) async {
//   // assert(input.length > 1 && input.length < 16);
//   List<String> matchingWords = [];
//   // late List<String>? correctList;
//   // correctList = CSW_lengthToSortedWordsArray[input.length.toString()] ?? [];

//   void recursiveHelper(String prefix, int remainingBlanks) {
//     // if no remaining blanks, check for pattern
//     if (remainingBlanks == 0) {
//       if (correctList!.contains(prefix)) {
//         matchingWords.add(prefix);
//       }
//       return;
//     } else {
//       for (int i = 0; i < alphabet.length; i++) {
//         // replace the first remaining blank in prefix with alphabet[i]
//         String newPrefix = prefix.replaceFirst("?", alphabet[i]);
//         int newRemainingBlanks = remainingBlanks - 1;
//         recursiveHelper(newPrefix, newRemainingBlanks);
//       }
//     }
//   }

//   int blanks = input.split("?").length - 1;

//   // send in word and number of blanks as arguments
//   recursiveHelper(input, blanks);

//   return matchingWords;
// }

Future<List<String>> _searchForPatterns2(
    String input, List<String>? correctList) async {
  List<String> possibleWords = [];

  for (String word in correctList!) {
    bool valid = true;
    for (int i = 0; i < word.length; i++) {
      if (input[i] != '?' && input[i] != word[i]) {
        valid = false;
        break;
      }
    }
    if (valid) {
      possibleWords.add(word);
    }
  }

  return possibleWords;
}

Future<List<String>> _searchForAnagramsOld(
    String sanitizedInput, Map<String, List<String>>? correctList) async {
  result = [];
  var sortedInputList = sanitizedInput.split('')..sort();
  var sortedInputString = sortedInputList.join();

  int numberOfBlanks = sortedInputString.split("?").length - 1;

  void searchAcross0Blanks() {
    result = correctList?[sortedInputString];
  }

  void searchAcross1Blanks() {
    // Use a for loop to iterate through each letter
    for (int i = 0; i < alphabet.length; i++) {
      String newQueryString = sortedInputString.replaceFirst("?", alphabet[i]);
      var list = newQueryString.split('')..sort();
      newQueryString = list.join();
      List<String>? tempResult = correctList?[newQueryString];

      if (tempResult != null) {
        result?.addAll(tempResult);
      }
    }
  }

  void searchAcross2Blanks() {
    // Use a for loop to iterate through each letter
    for (int i = 0; i < alphabet.length; i++) {
      String firstQueryString =
          sortedInputString.replaceFirst("?", alphabet[i]);
      for (int j = 0; j < alphabet.length; j++) {
        String secondQueryString =
            firstQueryString.replaceFirst("?", alphabet[j]);
        var templist = secondQueryString.split('')..sort();
        secondQueryString = templist.join();
        List<String>? tempResult = correctList?[secondQueryString];
        if (tempResult != null && result!.contains(tempResult[0]) == false) {
          result?.addAll(tempResult);
        }
      }
    }
  }

  void searchAcross3Blanks() {}

  if (numberOfBlanks == 0) {
    searchAcross0Blanks();
  } else if (numberOfBlanks == 1) {
    searchAcross1Blanks();
  } else if (numberOfBlanks == 2) {
    searchAcross2Blanks();
  } else {
    searchAcross3Blanks();
  }

  return result ?? [];
}

Future<List<String>> _searchForAnagrams(
    String input, Map<String, List<String>>? correctList) async {
  Set<String> anagrams = Set<String>(); // Use a Set instead of a List

  List<String> allPossibleAlphanagrams = generateAlphabeticStrings(input);

  // edge cases
  if (correctList == null) {
    return [];
  }
  var sortedInputList = input.split('')..sort();
  var sortedInputString = sortedInputList.join();
  if (!input.contains("?")) {
    return correctList[sortedInputString] ?? [];
  }
  // for each key in the anagram map
  for (String keyAlphanagram in correctList!.keys) {
    for (int i = 0; i < allPossibleAlphanagrams.length; i++) {
      bool valid = true;

      String currPossibleAlphanagram = allPossibleAlphanagrams[i];
      for (int j = 0; j < currPossibleAlphanagram.length; j++) {
        if (currPossibleAlphanagram[j] != '?' &&
            currPossibleAlphanagram[j] != keyAlphanagram[j]) {
          valid = false;
          break;
        }
      }
      if (valid) {
        anagrams.addAll(correctList[keyAlphanagram]!);
      }
    }
  }

  return anagrams.toList(); // Convert the Set to a List before returning
}

List<String> generateAlphabeticStrings(String inputString) {
  List<String> characters = inputString.split('');

  List<String> questionMarks = characters.where((char) => char == '?').toList();

  characters.removeWhere((char) => char == '?');

  characters.sort();

  Set<String> result = {(characters.join())};

  for (int i = 0; i < questionMarks.length; i++) {
    Set<String> newResult = Set();
    for (String str in result) {
      for (int j = 0; j <= str.length; j++) {
        String newString =
            str.substring(0, j) + questionMarks[i] + str.substring(j);
        newResult.add(newString);
      }
    }
    result = Set.from(newResult);
  }

  return result.toList(); // Convert back to a list for consistent output.
}

// void main() {
//   _searchForAnagrams("ZYZZYV?", CSW21_7_ANAGRAMS);
// }
